# 1220_day12
## 클린코드 ch.13 동시성
### 동시성 프로그래밍
- 어플리케이션을 효율적으로 실행하기 위해 멀티코어를 온전히 활용하도록 하는 구현 방식
- 외부 서비스를 기다리면서 아무것도 하지않으면 cpu 사이클이 낭비된다.
- 낭비되는 자원을 줄이기 위한 방식이다.
### 동시성의 오해
1. 동시성은 항상 성능을 높여준다. x -> 동시성은 떼로 성능을 높여준다. o
- 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할수 있거나, 여러 프로세서가 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
- 여러가지 이미지 리소소를 다운로드 할 때
2. 동시성을 구현해도 설계가 바뀌지 않는다. x -> 동시성을 구현하면 설계를 바꿔야한다, o
- 단일 스레드 시스템과 다중 스레드 시스템의 설계는 많이 다르다.
- '무엇'과 '언제'를 분리하면 시스템의 구조가 크게 달라진다.
3. web이나 ejb와 같은 컨테이너를 사용하면 동시성을  이해할 필요가 없다 x -> 컨테이너를 사용해도 동시성을 이해해야한다 o
- 어플리케이션이 컨테이너를 통해 멀티 스레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야한다.
- 동시 수정, 데드락 같은 문제를 피할 수 있는지를 알아야 한다.

### 동시성 프로그래밍을 안전하게 짜는 방법
1. 단일 책임 원칙(SRP) 설계
- **동시성 관련 코드는 다른 코드와 분리하라**
2. 자료 범위를 제한
- **공유 자료를 최대한 줄여라**
- 동시 수정 문제를 피하기 위해 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라
- 보호할 임계영역을 빼먹거나, 모든 임계영역을 보호했는지 확인하느라 수고가 드므로 **임계영역의 수를 최소화 해야 한다.**
3. 자료 사본을 사용
- 공유 자료를 줄이려면 최대한 공유하지 않는게 제일 좋다.
- 객체를 복사해 읽기 전용으로 사용한다.
- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 헤당 사본에서 결과를 가져온다.
- 사본을 사용하는 방식으로 내부 잠금을 없애 수행 시간을 절약하는 것이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.
4. 스레드는 독립적으로 구현
- **다른 스레드와 정보를 공유하지 않는다.**
- 각 스레드는 클라이언트 요청 하나를 처리한다.
- 모든 정보는 비공유 출처(client의 request)에서 가져오며 로컬 변수에 저장한다.
- 마치 자신의 독자적인 시스템에서 동작하는 양 요청을 처리한다.
5. 라이브러리를 이해
- 
6. 동기화하는 메서드 사이에 존재하는 의존성을 이해
- **공유 객체 하나에는 메서드 하나만 사용하라**
- 클라이언트에서 잠금 : 클라이언트에사 첫번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할때까지 잠금을 유지한다.
- 서버에서 잠금 : 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. 클라이언트에선 이 메서드를 호출하기만 하면 된다.
- 연결(Adapter) 서버 : 잠금을 수행하는 중간 단계를 실행한다. '서버에서 잠금'방식과 유사하지만 원래 서버는 변경하지 않는다.

